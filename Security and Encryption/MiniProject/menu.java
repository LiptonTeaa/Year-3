import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Scanner;

public class menu {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Create a scanner object to read user input from the console
        RSAKeyPair keyPair = null;  // Create a key pair object to store the key pair generated by the user

        while (true){
            System.out.println(" IS53012C: Security and Encryption (2022-23) MINI Project " +
                    " by brahath-SHET, umar SULTAN, aerhan SRIRANGAN" + "\n"
                    + "RSA Menu:");
            System.out.println();
            System.out.println("1. Q1 Generate RSA key pair");
            System.out.println("2. Q2 Encrypt");
            System.out.println("3. Q3 Decrypt");
            System.out.println("4. Exit");
            System.out.print("Please input a single digit from the options above (1-4) : ");
            try {
            int choice = scanner.nextInt(); // Read the user's choice
            switch (choice) { // Switch on the user's choice
                case 1:
                    System.out.print("Please input the key size (in bits, only works for 64 bits/5 letters above currently): ");
                    int keySize = scanner.nextInt(); // Read the key size from the user
                    keyPair = RSAKeyPair.generateKeyPair(keySize); // Generate a key pair
                    System.out.println("Public key (e, n): " + RSAKeyPair.publicKey); // Print the public key
                    System.out.println("Private key (d, n): " + RSAKeyPair.privateKey); // Print the private key
                    break;
                case 2:
                    if (keyPair == null) {
                        System.out.println("Please generate a key pair first!");
                        break;
                    }
                    System.out.print("Please input the message to be encrypted: ");
                    scanner.nextLine();
                    String message = scanner.nextLine(); // Read the message to be encrypted
                    // check if the message is alphanumeric
                    boolean isAlphaNumeric = message != null &&
                            (message.chars().allMatch(Character::isLetterOrDigit)
                            || message.chars().anyMatch(Character::isSpaceChar));
                    if (isAlphaNumeric) {
                        BigInteger encryptedMessage = encrypt(message, RSAKeyPair.publicKey); // Encrypt the message
                        System.out.println("Encrypted message: " + encryptedMessage); // Print the encrypted message
                    }
                    else {
                        throw new IllegalArgumentException("Input only alphanumeric characters");
                    }
                    break;
                case 3:
                    if (keyPair == null) {
                        System.out.println("Please generate a key pair first!");
                        break;
                    }
                    System.out.print("Please input the message to be decrypted: ");
                    scanner.nextLine();
                    String ciphertext = scanner.nextLine();
                    BigInteger m1 = new BigInteger(ciphertext); // Convert the message to a BigInteger
                    BigInteger c = new BigInteger(m1.toString());
                    String decryptedMessage = decrypt(c, RSAKeyPair.privateKey);
                    System.out.println("Decrypted message: " + decryptedMessage);
                    break;
                case 4:
                    System.out.println("Goodbye!");
                    System.exit(0);
                    break;
                default:
                    System.out.println("Invalid input! Please try again."); // If the user's choice is not 1, 2, 3 or 4, print an error message
                    break;
            }
            }catch(NumberFormatException e){
                System.out.println("Invalid input! Please try again.");
            }
        }
    }
    public static class RSAKeyPair {
        public static RSAPublicKey publicKey; // Public key
        public static RSAPrivateKey privateKey; // Private key

        RSAKeyPair(RSAPublicKey publicKey, RSAPrivateKey privateKey){
            RSAKeyPair.publicKey = publicKey;
            RSAKeyPair.privateKey = privateKey;
        }
        public static RSAKeyPair generateKeyPair(int keySize) {
            SecureRandom random = new SecureRandom(); // Generate a random number
            BigInteger p = BigInteger.probablePrime(keySize / 2, random);
            BigInteger q = BigInteger.probablePrime(keySize / 2, random);
            BigInteger n = p.multiply(q); // n is the product of p and q
            BigInteger phi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE)); // phi is the totient of n

            BigInteger e = BigInteger.valueOf(1);

            BigInteger t = phi.subtract(BigInteger.TWO); // t is the value of phi - 2

            for (BigInteger bi = t;
                 bi.compareTo(BigInteger.ZERO) > 0;  // Loop to find the value of e
                 bi = bi.subtract(BigInteger.ONE)){ // Loop to find the value of e
                int res = (phi.gcd(bi)).compareTo(e); //Should return zero if gcd is equal to 1
                if (res == 0){ // if gcd is equal to 1 then break the loop and assign the value of bi to e (public key) and continue with the program execution
                    e = bi;
                    break; // break the loop
                }
            }
            while (phi.gcd(e).compareTo(BigInteger.ONE) > 0 && e.compareTo(phi) < 0){ // e is the public key and should be coprime to phi and less than phi (1 < e < phi)
                e.add(BigInteger.ONE); // e is the public key
            }
            BigInteger d = e.modInverse(phi); // d is the private key
            RSAPublicKey publicKey = new RSAPublicKey(e, n); // Create a public key
            RSAPrivateKey privateKey = new RSAPrivateKey(d, n);  // Create a private key
            return new RSAKeyPair(publicKey, privateKey); // Return the key pair
        }
    }
    // Public key class
    public static class RSAPublicKey {
        BigInteger e;
        BigInteger n;
        RSAPublicKey(BigInteger e, BigInteger n){
            this.e = e; // e is the same for both public and private keys
            this.n = n; // n is the same for both public and private keys
        }
        @Override
        public String toString(){
            return "(" + e + ", " + n + ")";
        }
    }
    // Private key class
    public static class RSAPrivateKey {
        BigInteger d;
        BigInteger n;

        RSAPrivateKey(BigInteger d, BigInteger n){ // Constructor
            this.d = d; // d is the same for both public and private keys
            this.n = n; // n is the same for both public and private keys
        }
        @Override
        public String toString(){ // This is to print the private key
            return "(" + d + ", " + n + ")";
        }
    }
    // Encryption function
    public static BigInteger encrypt(String message, RSAPublicKey publicKey){
        return new BigInteger(message.getBytes()).modPow(publicKey.e, publicKey.n);
    }
    // Decryption function
    public static String decrypt(BigInteger encryptedMessage, RSAPrivateKey privateKey){
        return new String(encryptedMessage.modPow(privateKey.d, privateKey.n).toByteArray());
    }
}